//! Draw commands that represent what to render.

use spark_core::{Color, GlyphInstance, Rect};

/// A single draw command representing a primitive to render.
#[derive(Clone, Debug)]
pub enum DrawCommand {
    /// Draw a filled rectangle with optional rounded corners.
    Rect {
        bounds: Rect,
        color: Color,
        corner_radius: f32,
        border_width: f32,
        border_color: Color,
    },
    /// Draw text glyphs.
    Text {
        glyphs: Vec<GlyphInstance>,
    },
    /// Push a clip rectangle (future draw commands will be clipped).
    PushClip {
        bounds: Rect,
    },
    /// Pop the current clip rectangle.
    PopClip,
    /// Push a translation offset (affects all subsequent draw commands).
    PushTranslation {
        offset: (f32, f32),
    },
    /// Pop the current translation offset.
    PopTranslation,
}

impl DrawCommand {
    /// Create a simple filled rectangle.
    pub fn rect(bounds: Rect, color: Color) -> Self {
        Self::Rect {
            bounds,
            color,
            corner_radius: 0.0,
            border_width: 0.0,
            border_color: Color::TRANSPARENT,
        }
    }

    /// Create a rounded rectangle.
    pub fn rounded_rect(bounds: Rect, color: Color, radius: f32) -> Self {
        Self::Rect {
            bounds,
            color,
            corner_radius: radius,
            border_width: 0.0,
            border_color: Color::TRANSPARENT,
        }
    }

    /// Create a rectangle with a border.
    pub fn bordered_rect(
        bounds: Rect,
        color: Color,
        corner_radius: f32,
        border_width: f32,
        border_color: Color,
    ) -> Self {
        Self::Rect {
            bounds,
            color,
            corner_radius,
            border_width,
            border_color,
        }
    }
}

/// A list of draw commands to be rendered in order.
#[derive(Clone, Debug, Default)]
pub struct DrawList {
    commands: Vec<DrawCommand>,
}

impl DrawList {
    /// Create an empty draw list.
    pub fn new() -> Self {
        Self::default()
    }

    /// Add a draw command to the list.
    pub fn push(&mut self, command: DrawCommand) {
        self.commands.push(command);
    }

    /// Draw a filled rectangle.
    pub fn rect(&mut self, bounds: Rect, color: Color) {
        self.push(DrawCommand::rect(bounds, color));
    }

    /// Draw a rounded rectangle.
    pub fn rounded_rect(&mut self, bounds: Rect, color: Color, radius: f32) {
        self.push(DrawCommand::rounded_rect(bounds, color, radius));
    }

    /// Draw a rectangle with a border.
    pub fn bordered_rect(
        &mut self,
        bounds: Rect,
        color: Color,
        corner_radius: f32,
        border_width: f32,
        border_color: Color,
    ) {
        self.push(DrawCommand::bordered_rect(
            bounds,
            color,
            corner_radius,
            border_width,
            border_color,
        ));
    }

    /// Draw text glyphs.
    pub fn text(&mut self, glyphs: Vec<GlyphInstance>) {
        if !glyphs.is_empty() {
            self.push(DrawCommand::Text { glyphs });
        }
    }

    /// Push a clip rectangle.
    pub fn push_clip(&mut self, bounds: Rect) {
        self.push(DrawCommand::PushClip { bounds });
    }

    /// Pop the current clip rectangle.
    pub fn pop_clip(&mut self) {
        self.push(DrawCommand::PopClip);
    }

    /// Push a translation offset for subsequent draw commands.
    pub fn push_translation(&mut self, offset: (f32, f32)) {
        self.push(DrawCommand::PushTranslation { offset });
    }

    /// Pop the current translation offset.
    pub fn pop_translation(&mut self) {
        self.push(DrawCommand::PopTranslation);
    }

    /// Get all commands.
    pub fn commands(&self) -> &[DrawCommand] {
        &self.commands
    }

    /// Clear all commands.
    pub fn clear(&mut self) {
        self.commands.clear();
    }

    /// Check if the list is empty.
    pub fn is_empty(&self) -> bool {
        self.commands.is_empty()
    }

    /// Get the number of commands.
    pub fn len(&self) -> usize {
        self.commands.len()
    }
}
